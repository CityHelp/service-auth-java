package com.crudzaso.cityhelp.auth.unit.infrastructure.security;

import com.crudzaso.cityhelp.auth.infrastructure.security.RsaKeyProvider;
import com.crudzaso.cityhelp.auth.unit.infrastructure.InfrastructureUnitTest;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.Base64;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatCode;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Comprehensive unit tests for RsaKeyProvider.
 *
 * Tests RSA key generation, loading from configuration, and key access methods.
 * Verifies proper initialization and error handling for both development and production scenarios.
 *
 * <p>This test class covers:</p>
 * <ul>
 *   <li>Happy path: Key generation when configuration is empty</li>
 *   <li>Happy path: Key loading from PEM configuration</li>
 *   <li>Error cases: Invalid PEM format, corrupted keys, missing configuration</li>
 *   <li>Edge cases: Key ID configuration, JWKS format conversion</li>
 *   <li>Security: Proper RSA key pair generation and format</li>
 * </ul>
 */
@ExtendWith(MockitoExtension.class)
@DisplayName("RsaKeyProvider - RSA Key Management")
class RsaKeyProviderTest extends InfrastructureUnitTest {

    private RsaKeyProvider rsaKeyProvider;
    private static final String DEFAULT_KEY_ID = "cityhelp-key-1";
    private static final String CUSTOM_KEY_ID = "custom-test-key-1";

    @BeforeEach
    @Override
    protected void setUp() {
        super.setUp();
        rsaKeyProvider = new RsaKeyProvider();
    }

    @Test
    @DisplayName("should initialize with auto-generated keys when configuration is empty")
    void shouldInitializeWithAutoGeneratedKeys_WhenConfigurationIsEmpty() {
        // Arrange
        ReflectionTestUtils.setField(rsaKeyProvider, "privateKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "publicKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "keyId", DEFAULT_KEY_ID);

        // Act & Assert
        assertThatCode(() -> rsaKeyProvider.init())
                .doesNotThrowAnyException();

        // Verify keys were generated
        assertThat(rsaKeyProvider.getPrivateKey()).isNotNull();
        assertThat(rsaKeyProvider.getPublicKey()).isNotNull();
        assertThat(rsaKeyProvider.getKeyId()).isEqualTo(DEFAULT_KEY_ID);
    }

    @Test
    @DisplayName("should load keys from valid PEM configuration")
    void shouldLoadKeysFromValidPemConfiguration() throws Exception {
        // Arrange
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(2048);
        KeyPair keyPair = keyPairGenerator.generateKeyPair();

        String privateKeyPem = convertToPem(keyPair.getPrivate().getEncoded(), "PRIVATE KEY");
        String publicKeyPem = convertToPem(keyPair.getPublic().getEncoded(), "PUBLIC KEY");

        ReflectionTestUtils.setField(rsaKeyProvider, "privateKeyPem", privateKeyPem);
        ReflectionTestUtils.setField(rsaKeyProvider, "publicKeyPem", publicKeyPem);
        ReflectionTestUtils.setField(rsaKeyProvider, "keyId", CUSTOM_KEY_ID);

        // Act
        rsaKeyProvider.init();

        // Assert
        assertThat(rsaKeyProvider.getPrivateKey()).isNotNull();
        assertThat(rsaKeyProvider.getPublicKey()).isNotNull();
        assertThat(rsaKeyProvider.getKeyId()).isEqualTo(CUSTOM_KEY_ID);
    }

    @Test
    @DisplayName("should throw exception when private key PEM is invalid")
    void shouldThrowException_WhenPrivateKeyPemIsInvalid() throws Exception {
        // Arrange
        String invalidPrivateKeyPem = "-----BEGIN PRIVATE KEY-----\nINVALID_BASE64_DATA\n-----END PRIVATE KEY-----";
        String validPublicKeyPem = generateValidPublicKeyPem();

        ReflectionTestUtils.setField(rsaKeyProvider, "privateKeyPem", invalidPrivateKeyPem);
        ReflectionTestUtils.setField(rsaKeyProvider, "publicKeyPem", validPublicKeyPem);
        ReflectionTestUtils.setField(rsaKeyProvider, "keyId", DEFAULT_KEY_ID);

        // Act & Assert
        assertThatThrownBy(() -> rsaKeyProvider.init())
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("RSA key initialization failed");
    }

    @Test
    @DisplayName("should throw exception when public key PEM is invalid")
    void shouldThrowException_WhenPublicKeyPemIsInvalid() throws Exception {
        // Arrange
        String validPrivateKeyPem = generateValidPrivateKeyPem();
        String invalidPublicKeyPem = "-----BEGIN PUBLIC KEY-----\nINVALID_BASE64_DATA\n-----END PUBLIC KEY-----";

        ReflectionTestUtils.setField(rsaKeyProvider, "privateKeyPem", validPrivateKeyPem);
        ReflectionTestUtils.setField(rsaKeyProvider, "publicKeyPem", invalidPublicKeyPem);
        ReflectionTestUtils.setField(rsaKeyProvider, "keyId", DEFAULT_KEY_ID);

        // Act & Assert
        assertThatThrownBy(() -> rsaKeyProvider.init())
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("RSA key initialization failed");
    }

    @Test
    @DisplayName("should generate keys automatically when only one key is provided")
    void shouldGenerateKeysAutomatically_WhenOnlyOneKeyIsProvided() throws Exception {
        // Arrange - Only private key provided
        String validPrivateKeyPem = generateValidPrivateKeyPem();

        ReflectionTestUtils.setField(rsaKeyProvider, "privateKeyPem", validPrivateKeyPem);
        ReflectionTestUtils.setField(rsaKeyProvider, "publicKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "keyId", DEFAULT_KEY_ID);

        // Act
        rsaKeyProvider.init();

        // Assert - Should generate new keys automatically (not throw exception)
        assertThat(rsaKeyProvider.getPrivateKey()).isNotNull();
        assertThat(rsaKeyProvider.getPublicKey()).isNotNull();
        assertThat(rsaKeyProvider.getKeyId()).isEqualTo(DEFAULT_KEY_ID);

        // Note: The original private key from configuration is ignored and new keys are generated
        // This is the expected behavior when configuration is incomplete
    }

    @Test
    @DisplayName("should return correct key ID")
    void shouldReturnCorrectKeyId() throws Exception {
        // Arrange
        ReflectionTestUtils.setField(rsaKeyProvider, "privateKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "publicKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "keyId", CUSTOM_KEY_ID);

        // Act
        rsaKeyProvider.init();

        // Assert
        assertThat(rsaKeyProvider.getKeyId()).isEqualTo(CUSTOM_KEY_ID);
    }

    @Test
    @DisplayName("should return public key components in Base64 URL format")
    void shouldReturnPublicKeyComponentsInBase64UrlFormat() throws Exception {
        // Arrange
        ReflectionTestUtils.setField(rsaKeyProvider, "privateKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "publicKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "keyId", DEFAULT_KEY_ID);

        rsaKeyProvider.init();

        // Act
        String modulus = rsaKeyProvider.getPublicKeyModulus();
        String exponent = rsaKeyProvider.getPublicKeyExponent();

        // Assert
        assertThat(modulus).isNotNull().isNotBlank();
        assertThat(exponent).isNotNull().isNotBlank();

        // Verify it's valid Base64 URL encoded (no padding, URL safe)
        assertThat(modulus).doesNotContain("+").doesNotContain("/").doesNotContain("=");
        assertThat(exponent).doesNotContain("+").doesNotContain("/").doesNotContain("=");

        // Verify they can be decoded
        assertThatCode(() -> Base64.getUrlDecoder().decode(modulus)).doesNotThrowAnyException();
        assertThatCode(() -> Base64.getUrlDecoder().decode(exponent)).doesNotThrowAnyException();
    }

    @Test
    @DisplayName("should generate RSA 2048-bit keys")
    void shouldGenerateRsa2048BitKeys() throws Exception {
        // Arrange
        ReflectionTestUtils.setField(rsaKeyProvider, "privateKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "publicKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "keyId", DEFAULT_KEY_ID);

        // Act
        rsaKeyProvider.init();

        // Assert
        RSAPublicKey publicKey = rsaKeyProvider.getPublicKey();
        assertThat(publicKey.getModulus().bitLength()).isEqualTo(2048);
    }

    @Test
    @DisplayName("should handle null key ID gracefully")
    void shouldHandleNullKeyIdGracefully() throws Exception {
        // Arrange
        ReflectionTestUtils.setField(rsaKeyProvider, "privateKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "publicKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "keyId", null);

        // Act
        rsaKeyProvider.init();

        // Assert
        assertThat(rsaKeyProvider.getKeyId()).isNull();
    }

    @Test
    @DisplayName("should log warning when auto-generating keys in development")
    void shouldLogWarning_WhenAutoGeneratingKeysInDevelopment() throws Exception {
        // Arrange
        ReflectionTestUtils.setField(rsaKeyProvider, "privateKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "publicKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "keyId", DEFAULT_KEY_ID);

        // Act & Assert
        // The component should initialize successfully even though it logs a warning
        assertThatCode(() -> rsaKeyProvider.init())
                .doesNotThrowAnyException();

        // Verify keys were generated (this is the important part)
        assertThat(rsaKeyProvider.getPrivateKey()).isNotNull();
        assertThat(rsaKeyProvider.getPublicKey()).isNotNull();
        assertThat(rsaKeyProvider.getKeyId()).isEqualTo(DEFAULT_KEY_ID);

        // Note: In a real scenario, we would verify the log warning using a test appender
        // but for this test we focus on functional behavior
    }

    @Test
    @DisplayName("should handle empty key ID gracefully")
    void shouldHandleEmptyKeyIdGracefully() throws Exception {
        // Arrange
        ReflectionTestUtils.setField(rsaKeyProvider, "privateKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "publicKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "keyId", "");

        // Act
        rsaKeyProvider.init();

        // Assert
        assertThat(rsaKeyProvider.getKeyId()).isEqualTo("");
    }

    @Test
    @DisplayName("should generate different keys across multiple initializations")
    void shouldGenerateDifferentKeys_AcrossMultipleInitializations() throws Exception {
        // Arrange
        ReflectionTestUtils.setField(rsaKeyProvider, "privateKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "publicKeyPem", "");
        ReflectionTestUtils.setField(rsaKeyProvider, "keyId", DEFAULT_KEY_ID);

        // Act
        rsaKeyProvider.init();
        RSAPrivateKey firstPrivateKey = rsaKeyProvider.getPrivateKey();
        RSAPublicKey firstPublicKey = rsaKeyProvider.getPublicKey();

        // Initialize again (should generate new keys)
        rsaKeyProvider.init();
        RSAPrivateKey secondPrivateKey = rsaKeyProvider.getPrivateKey();
        RSAPublicKey secondPublicKey = rsaKeyProvider.getPublicKey();

        // Assert - Keys should be different but valid
        assertThat(firstPrivateKey).isNotEqualTo(secondPrivateKey);
        assertThat(firstPublicKey).isNotEqualTo(secondPublicKey);

        // Both should be valid 2048-bit keys
        assertThat(firstPublicKey.getModulus().bitLength()).isEqualTo(2048);
        assertThat(secondPublicKey.getModulus().bitLength()).isEqualTo(2048);
    }

    @Test
    @DisplayName("should clean PEM keys correctly by removing headers and whitespace")
    void shouldCleanPemKeysCorrectly() throws Exception {
        // Arrange
        String privateKeyWithHeaders = generateValidPrivateKeyPem();
        String publicKeyWithHeaders = generateValidPublicKeyPem();

        ReflectionTestUtils.setField(rsaKeyProvider, "privateKeyPem", privateKeyWithHeaders);
        ReflectionTestUtils.setField(rsaKeyProvider, "publicKeyPem", publicKeyWithHeaders);
        ReflectionTestUtils.setField(rsaKeyProvider, "keyId", DEFAULT_KEY_ID);

        // Act
        rsaKeyProvider.init();

        // Assert - If keys are cleaned properly, initialization should succeed
        assertThat(rsaKeyProvider.getPrivateKey()).isNotNull();
        assertThat(rsaKeyProvider.getPublicKey()).isNotNull();
    }

    /**
     * Helper method to convert byte array to PEM format.
     */
    private String convertToPem(byte[] keyBytes, String keyType) {
        String base64Key = Base64.getEncoder().encodeToString(keyBytes);
        StringBuilder pem = new StringBuilder();
        pem.append("-----BEGIN ").append(keyType).append("-----\n");

        // Split into 64-character lines
        for (int i = 0; i < base64Key.length(); i += 64) {
            int endIndex = Math.min(i + 64, base64Key.length());
            pem.append(base64Key, i, endIndex).append("\n");
        }

        pem.append("-----END ").append(keyType).append("-----");
        return pem.toString();
    }

    /**
     * Helper method to generate a valid private key PEM.
     */
    private String generateValidPrivateKeyPem() throws Exception {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(2048);
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        return convertToPem(keyPair.getPrivate().getEncoded(), "PRIVATE KEY");
    }

    /**
     * Helper method to generate a valid public key PEM.
     */
    private String generateValidPublicKeyPem() throws Exception {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(2048);
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        return convertToPem(keyPair.getPublic().getEncoded(), "PUBLIC KEY");
    }
}